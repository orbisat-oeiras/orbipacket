\documentclass[a4paper,11pt,english]{article}
\usepackage{standalone}
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing,arrows.meta}
\usepackage{babel}
\usepackage{booktabs}
\usepackage[colorlinks,pdfstartview=FitH,bookmarks,pdfcenterwindow]{hyperref}
\usepackage[capitalise]{cleveref}

\makeatletter

\def\@autolabel#1{%
\expandafter\let\csname old#1\expandafter\endcsname\csname#1\endcsname
\expandafter\def\csname @#1@label\endcsname[##1]##2{\csname old#1\endcsname{##2}\label{#1:##1}}
\expandafter\def\csname #1\endcsname{\expandafter\@ifnextchar[{\csname @#1@label\endcsname}{\csname old#1\endcsname}}
}

\@autolabel{part}
\@autolabel{section}
\@autolabel{subsection}
\@autolabel{subsubsection}
\@autolabel{paragraph}
\@autolabel{subparagraph}

\makeatother

\title{OrbiPacket Protocol Specification - v1.2.0}
\author{The OrbiSat Oeiras Team}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

OrbiPacket is a packet-based communication protocol. It was created specifically for communication with CanSat devices. These devices can be fitted with very diverse electronics, and are often resource-constrained. Thus, this protocol has the goals of being simple and easy to use while providing decent efficiency and minimal overhead.

\textit{\textbf{A bit of history.} The OrbiSat Oeiras team first participated in the CanSat Portugal competition in 2023/2024, being one of the finalists of the 11th edition. Several issues on all fronts meant no data was received during the CanSat's descent. The next year, wanting to get everything right, the team's firmware developer (aka me, Levi Gomes) decided sending data over text wasn't neither efficient nor rigorous enough. So, after some effort, the first version of OrbiPacket was born during the 12th edition of the competition, in 2024/2025. And in case you're curious... no, we still didn't get any data.}

\input{diagram.tex}

\section{Packet Structure}

Each packet consists of the following fields, which must be encoded in the specified order:

\begin{table}[h]
  \centering
  \begin{tabular}{lll}
    \toprule
    Field                     & Size (bytes) & Description                                                     \\
    \midrule
    \textbf{Header}           & 11           & Contains metadata for packet processing.                        \\
    Version                   & 1            & Protocol version for compatibility management.                  \\
    Length                    & 1            & Size of the payload in bytes.                                   \\
    Control                   & 1            & Encodes packet type and device ID.                              \\
    Timestamp                 & 8            & Time since Unix epoch in nanoseconds (64-bit unsigned integer). \\
    \textbf{Payload}          & 0-255        & Application-specific data.                                      \\
    \textbf{CRC}              & 2            & Cyclic redundancy check for error detection.                    \\
    \textbf{Termination Byte} & 1            & A fixed value (`0x00`) marking the end of the packet.           \\
    \bottomrule
  \end{tabular}
  \caption{Packet structure overview}
  \label{table:struct}
\end{table}

\section{Packet Fields}

\subsection{Header}

\subsubsection{Version}
\begin{itemize}
  \item \textbf{Size}: 1 byte
  \item \textbf{Description}: Indicates the protocol version. Breaking updates to the protocol increment this field to ensure backwards compatibility.
  \item \textbf{Value}: the current version of the protocol (1.2.0) specifies \texttt{0x01} as the version byte.
\end{itemize}

\subsubsection{Length}
\begin{itemize}
  \item \textbf{Size}: 1 byte
  \item \textbf{Description}: Specifies the size of the payload in bytes, ranging from 0 to 255.
\end{itemize}

\subsubsection{Control}
\begin{itemize}
  \item \textbf{Size}: 1 byte
  \item \textbf{Description}: Encodes metadata about the packet type and device identifier. The following fields are specified from the highest bit to the lowest bit.
        \begin{itemize}
          \item \textbf{TM/TC Flag}: 1 bit, where \texttt{0} indicates telemetry and \texttt{1} indicates a telecommand.
          \item \textbf{Device ID}: 5 bits, uniquely identifying the source device for TM or target device for TC. Note that device IDs should remain consistent across TM and TC packets.
          \item \textbf{Reserved Bits}: 2 bits, reserved for future use. The value of this field should be ignored.
        \end{itemize}
\end{itemize}

\subsubsection{Timestamp}
\begin{itemize}
  \item \textbf{Size}: 8 bytes
  \item \textbf{Description}: Represents the time since the Unix epoch in nanoseconds as a 64-bit unsigned integer.
\end{itemize}

\subsection{Payload}
\begin{itemize}
  \item \textbf{Size}: 0â€“255 bytes
  \item \textbf{Description}: Contains application-specific data, such as telemetry readings or command instructions. The structure of the payload is currently up to the application, but that may be subject to change in future versions.
\end{itemize}

\subsection{CRC}
\begin{itemize}
  \item \textbf{Size}: 2 bytes
  \item \textbf{Description}: Cyclic redundancy check value computed over all preceding fields (excluding the termination byte). The generator polynomial used by the protocol is \href{https://reveng.sourceforge.io/crc-catalogue/all.htm#crc.cat.crc-16-opensafety-b}{CRC-16/OPENSAFETY-B}, or \texttt{0xbaad} in Koopman's notation.
\end{itemize}

\subsection{Termination Byte}
\begin{itemize}
  \item \textbf{Size}: 1 byte
  \item \textbf{Description}: Marks the end of the packet, ensuring clear packet delimitation.
  \item \textbf{Value}: Fixed at \texttt{0x00}
\end{itemize}

\section{Field Order and Endianness}

Packet fields must be encoded in the specified order, as a byte string. Multi-byte fields are encoded in \textbf{little-endian}.

\section{Encoding}

To prevent the occurrence of the termination byte (\texttt{0x00}) within the packet, the protocol employs \textbf{COBS (Consistent Overhead Byte Stuffing)} encoding. This encoding is applied to all fields except the termination byte itself, simplifying parsing and improving error resilience.

\section{Packet Operations}

\subsection{Creation}
\begin{itemize}
  \item Packet fields, excluding the CRC and termination bytes, are converted into binary and chained together in the specified order.
  \item A CRC is computed over the resulting binary string, and appended to it.
  \item COBS encoding is applied to the entire binary string, and the termination byte is appended to it, concluding packet creation.
\end{itemize}

\subsection{Transmission}
\begin{itemize}
  \item Packets are transmitted in binary, over an application-specific digital or physical medium (e.g. radio).
\end{itemize}

\subsection{Reception}
\begin{itemize}
  \item Packets are decoded using COBS
  \item The packet structure is recovered from the decoded binary string.
\end{itemize}

\subsection{Validation}
\begin{itemize}
  \item Packets which don't start at \texttt{0x00} (the termination byte of the previous packet) are discarded. This allows for re-synchronization in case of a broken or lossy connection.
  \item Packets which cannot be properly decoded with COBS are discarded.
  \item Packets which fail CRC validation are discarded.
  \item Packets with erroneous length fields are discarded.
\end{itemize}

\subsection{Acknowledgment and Retransmission}
Acknowledgment of packets, and their retransmission in case of packet loss, is not currently required by the protocol. It is up to implementations to decide if, and how, this is handled.

\subsection{Version Negotiation}
No version negotiation strategy is enforced by the packed in the event of communicators having mismatched versions.


\section{Example Packet}

\begin{table}[h]
  \centering
  \begin{tabular}{lll}
    \toprule
    Field                & Example Value                       & Notes                     \\
    \midrule
    \textbf{Version}     & \texttt{0x01}                       & Protocol version 1.2.0    \\
    \textbf{Length}      & \texttt{0x04}                       & Payload size: 4 bytes     \\
    \textbf{Control}     & \texttt{0x81}                       & Telecommand, Device ID 1  \\
    \textbf{Timestamp}   & \texttt{0x000001787ABCEF0123456789} & Example timestamp         \\
    \textbf{Payload}     & \texttt{0xDEADBEEF}                 & Application-specific data \\
    \textbf{CRC}         & \texttt{0x5A}                       & Example CRC value         \\
    \textbf{Termination} & \texttt{0x00}                       & Packet terminator         \\
    \bottomrule
  \end{tabular}
  \caption{An example packet}
  \label{table:example}
\end{table}

\section{Packet Overhead}

The fixed fields (header and CRC) result in a total, unencoded overhead of 13 bytes, so packet sizes range from 13 to 268 bytes, depending on payload length. COBS encoding has a maximum overhead of 1 byte per 254 bytes of unencoded data. Thus, accounting for the termination byte, the maximum overhead is 15 or 16 bytes per packet.

\section{Implementation Guidelines}

If available, use a reference implementation of the protocol for the chosen language. Otherwise, make sure to conform to the specifications of this document.

\subsection{Versioning}

The protocol is versioned using \href{https://semver.org/}{Semantic Versioning}. Breaking changes always increment the version byte. Implementations of the protocol must clearly specify to the end user the supported protocol versions.

\subsection{CRC Computation}

The generator polynomial used by the protocol is \href{https://reveng.sourceforge.io/crc-catalogue/all.htm#crc.cat.crc-16-opensafety-b}{CRC-16/OPENSAFETY-B}, or \texttt{0xbaad} in Koopman's notation. The maximum packet length (excluding the CRC and termination bytes) is 255 + 11 = 266 bytes or 2128 bits. According to \href{https://users.ece.cmu.edu/~koopman/crc/c16/0xbaad_len.txt}{Koopman's research}, this polynomial can protect 7985 bits at a Hamming distance of 4 and 108 bits (equivalent to 2 bytes of payload data) at a Hamming distance of 5, with negligible protected lengths for higher Hamming distances. This is deemed sufficient for this protocol. The parameters of this polynomial are:

\begin{itemize}
  \item \textit{width}: \texttt{16}
  \item \textit{poly}: \texttt{0x755b}
  \item \textit{init}: \texttt{0x0000}
  \item \textit{refin}: \texttt{false}
  \item \textit{refout}: \texttt{false}
  \item \textit{xorout}: \texttt{0x0000}
  \item \textit{check}: \texttt{0x20fe}
  \item \textit{residue}: \texttt{0x0000}
\end{itemize}

\subsection{COBS}
Reference implementations of the COBS algorithm should be used whenever possible. Otherwise, refer to the literature for details on the encoding and decoding process. The packet data should be stuffed to remove the termination byte, that is, \texttt{0x00}.

\end{document}